// Compiled by ClojureScript 1.8.51 {:static-fns true, :optimize-constants true}
goog.provide('replumb.doc_maps');
goog.require('cljs.core');
replumb.doc_maps.special_doc_map = cljs.core.PersistentHashMap.fromArrays([cljs.core.cst$sym$try,cljs.core.cst$sym$do,cljs.core.cst$sym$if,cljs.core.cst$sym$new,cljs.core.cst$sym$ns,cljs.core.cst$sym$recur,cljs.core.cst$sym$set_BANG_,cljs.core.cst$sym$_DOT_,cljs.core.cst$sym$var,cljs.core.cst$sym$quote,cljs.core.cst$sym$throw,cljs.core.cst$sym$def],[new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$try,cljs.core.cst$sym$expr_STAR_,cljs.core.cst$sym$catch_DASH_clause_STAR_,cljs.core.cst$sym$finally_DASH_clause_QMARK_)], null),cljs.core.cst$kw$doc,"catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n  Catches and handles JavaScript exceptions."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$do,cljs.core.cst$sym$exprs_STAR_)], null),cljs.core.cst$kw$doc,"Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$if,cljs.core.cst$sym$test,cljs.core.cst$sym$then,cljs.core.cst$sym$else_QMARK_)], null),cljs.core.cst$kw$doc,"Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil."], null),new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$Constructor$,cljs.core.cst$sym$args_STAR_),cljs.core.list(cljs.core.cst$sym$new,cljs.core.cst$sym$Constructor,cljs.core.cst$sym$args_STAR_)], null),cljs.core.cst$kw$url,"java_interop#new",cljs.core.cst$kw$doc,"The args, if any, are evaluated from left to right, and\n  passed to the JavaScript constructor. The constructed object is\n  returned."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$name,cljs.core.cst$sym$docstring_QMARK_,cljs.core.cst$sym$attr_DASH_map_QMARK_,cljs.core.cst$sym$references_STAR_)], null),cljs.core.cst$kw$doc,"You must currently use the ns form only with the following caveats\n\n    * You must use the :only form of :use\n    * :require supports :as and :refer\n      - both options can be skipped\n      - in this case a symbol can be used as a libspec directly\n        - that is, (:require lib.foo) and (:require [lib.foo]) are both\n          supported and mean the same thing\n      - prefix lists are not supported\n    * The only option for :refer-clojure is :exclude\n    * :import is available for importing Google Closure classes\n      - ClojureScript types and records should be brought in with :use\n        or :require :refer, not :import ed\n    * Macros are written in Clojure, and are referenced via the new\n      :require-macros / :use-macros options to ns\n      - :require-macros and :use-macros support the same forms that\n        :require and :use do\n\n  Implicit macro loading: If a namespace is required or used, and that\n  namespace itself requires or uses macros from its own namespace, then\n  the macros will be implicitly required or used using the same\n  specifications. This oftentimes leads to simplified library usage,\n  such that the consuming namespace need not be concerned about\n  explicitly distinguishing between whether certain vars are functions\n  or macros.\n\n  Inline macro specification: As a convenience, :require can be given\n  either :include-macros true or :refer-macros [syms...]. Both desugar\n  into forms which explicitly load the matching Clojure file containing\n  macros. (This works independently of whether the namespace being\n  required internally requires or uses its own macros.) For example:\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn] :include-macros true]\n            [woz.core :as woz :refer [woz-fn] :refer-macros [app jx]]))\n\n  is sugar for\n\n  (ns testme.core\n  (:require [foo.core :as foo :refer [foo-fn]]\n            [woz.core :as woz :refer [woz-fn]])\n  (:require-macros [foo.core :as foo]\n                   [woz.core :as woz :refer [app jx]]))"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$recur,cljs.core.cst$sym$exprs_STAR_)], null),cljs.core.cst$kw$doc,"Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method."], null),new cljs.core.PersistentArrayMap(null, 3, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$set_BANG_,cljs.core.cst$sym$var_DASH_symbol,cljs.core.cst$sym$expr),cljs.core.list(cljs.core.cst$sym$set_BANG_,cljs.core.list(cljs.core.cst$sym$$_DASH_,cljs.core.cst$sym$instance_DASH_expr,cljs.core.cst$sym$instanceFieldName_DASH_symbol),cljs.core.cst$sym$expr)], null),cljs.core.cst$kw$url,"vars#set",cljs.core.cst$kw$doc,"Used to set vars and JavaScript object fields"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$$instanceMethod,cljs.core.cst$sym$instance,cljs.core.cst$sym$args_STAR_),cljs.core.list(cljs.core.cst$sym$$_DASH_instanceField,cljs.core.cst$sym$instance)], null),cljs.core.cst$kw$doc,"The instance member form works for methods and fields.\n  They all expand into calls to the dot operator at macroexpansion time."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$var,cljs.core.cst$sym$symbol)], null),cljs.core.cst$kw$doc,"The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x)."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$quote,cljs.core.cst$sym$form)], null),cljs.core.cst$kw$doc,"Yields the unevaluated form."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$throw,cljs.core.cst$sym$expr)], null),cljs.core.cst$kw$doc,"The expr is evaluated and thrown."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$forms,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(cljs.core.cst$sym$def,cljs.core.cst$sym$symbol,cljs.core.cst$sym$doc_DASH_string_QMARK_,cljs.core.cst$sym$init_QMARK_)], null),cljs.core.cst$kw$doc,"Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected."], null)]);
replumb.doc_maps.repl_special_doc_map = cljs.core.PersistentHashMap.fromArrays([cljs.core.cst$sym$doc,cljs.core.cst$sym$import,cljs.core.cst$sym$find_DASH_doc,cljs.core.cst$sym$dir,cljs.core.cst$sym$pst,cljs.core.cst$sym$in_DASH_ns,cljs.core.cst$sym$require,cljs.core.cst$sym$source,cljs.core.cst$sym$load_DASH_file,cljs.core.cst$sym$require_DASH_macros,cljs.core.cst$sym$apropos],[new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$name], null)),cljs.core.cst$kw$doc,"Prints documentation for a var or special form given its name"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$import_DASH_symbols_DASH_or_DASH_lists], null)),cljs.core.cst$kw$doc,"import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$re_DASH_string_DASH_or_DASH_pattern], null)),cljs.core.cst$kw$doc,"Prints documentation for any var whose documentation or name\n  contains a match for re-string-or-pattern"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$ns], null)),cljs.core.cst$kw$doc,"Prints a sorted directory of public vars in a namespace"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(cljs.core.PersistentVector.EMPTY,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$e], null)),cljs.core.cst$kw$doc,"Prints a stack trace of the exception.\n\n  If none supplied, uses the root cause of the most recent repl exception (*e)"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$name], null)),cljs.core.cst$kw$doc,"Sets *cljs-ns* to the namespace named by the symbol, creating it if needed."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null)),cljs.core.cst$kw$doc,"  Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace..\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure/string :as string])"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$name], null)),cljs.core.cst$kw$doc,"Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the source is available.\n\n  Example: (source filter)"], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$name], null)),cljs.core.cst$kw$doc,"Sequentially read and evaluate the set of forms\n                          contained in the file."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$_AMPERSAND_,cljs.core.cst$sym$args], null)),cljs.core.cst$kw$doc,"Similar to the require REPL special function but\n    only for macros."], null),new cljs.core.PersistentArrayMap(null, 2, [cljs.core.cst$kw$arglists,cljs.core.list(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.cst$sym$str_DASH_or_DASH_pattern], null)),cljs.core.cst$kw$doc,"Given a regular expression or stringable thing, return a seq of all\n  public definitions in all currently-loaded namespaces that match the\n  str-or-pattern."], null)]);
replumb.doc_maps.special_doc = (function replumb$doc_maps$special_doc(name_symbol){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic((replumb.doc_maps.special_doc_map.cljs$core$IFn$_invoke$arity$1 ? replumb.doc_maps.special_doc_map.cljs$core$IFn$_invoke$arity$1(name_symbol) : replumb.doc_maps.special_doc_map.call(null,name_symbol)),cljs.core.cst$kw$name,name_symbol,cljs.core.array_seq([cljs.core.cst$kw$special_DASH_form,true], 0));
});
replumb.doc_maps.repl_special_doc = (function replumb$doc_maps$repl_special_doc(name_symbol){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic((replumb.doc_maps.repl_special_doc_map.cljs$core$IFn$_invoke$arity$1 ? replumb.doc_maps.repl_special_doc_map.cljs$core$IFn$_invoke$arity$1(name_symbol) : replumb.doc_maps.repl_special_doc_map.call(null,name_symbol)),cljs.core.cst$kw$name,name_symbol,cljs.core.array_seq([cljs.core.cst$kw$repl_DASH_special_DASH_function,true], 0));
});
replumb.doc_maps.repl_special_QMARK_ = (function replumb$doc_maps$repl_special_QMARK_(form){
var and__5850__auto__ = cljs.core.seq_QMARK_(form);
if(and__5850__auto__){
var G__18380 = cljs.core.first(form);
return (replumb.doc_maps.repl_special_doc_map.cljs$core$IFn$_invoke$arity$1 ? replumb.doc_maps.repl_special_doc_map.cljs$core$IFn$_invoke$arity$1(G__18380) : replumb.doc_maps.repl_special_doc_map.call(null,G__18380));
} else {
return and__5850__auto__;
}
});
